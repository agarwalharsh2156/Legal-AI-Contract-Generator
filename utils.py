"""
Utility functions for the Legal AI Contract Generator
"""

import os
import re
import json
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path
import time

def setup_logging():
    """Setup logging configuration"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('legal_ai.log'),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger(__name__)

logger = setup_logging()

class RateLimiter:
    """Simple rate limiter for API calls"""
    
    def __init__(self, max_requests_per_minute: int = 15):
        self.max_requests = max_requests_per_minute
        self.requests = []
    
    def wait_if_needed(self):
        """Wait if rate limit would be exceeded"""
        now = time.time()
        # Remove requests older than 1 minute
        self.requests = [req_time for req_time in self.requests if now - req_time < 60]
        
        if len(self.requests) >= self.max_requests:
            # Calculate wait time
            oldest_request = min(self.requests)
            wait_time = 60 - (now - oldest_request) + 1
            if wait_time > 0:
                logger.info(f"Rate limit reached. Waiting {wait_time:.1f} seconds...")
                time.sleep(wait_time)
        
        self.requests.append(now)

def validate_contract_params(contract_type: str, params: Dict[str, Any]) -> Dict[str, Any]:
    """Validate contract parameters"""
    
    required_fields = {
        "NDA": ["party1", "party2", "date", "term", "jurisdiction"],
        "SERVICE": ["client", "provider", "services", "payment", "duration", "jurisdiction", "date"],
        "EMPLOYMENT": ["employer", "employee", "position", "salary", "start_date", "jurisdiction"]
    }
    
    if contract_type.upper() not in required_fields:
        return {"error": f"Unsupported contract type: {contract_type}"}
    
    missing_fields = []
    for field in required_fields[contract_type.upper()]:
        if field not in params or not params[field]:
            missing_fields.append(field)
    
    if missing_fields:
        return {"error": f"Missing required fields: {missing_fields}"}
    
    return {"valid": True}

def sanitize_filename(filename: str) -> str:
    """Sanitize filename for safe file system operations"""
    # Remove invalid characters
    sanitized = re.sub(r'[<>:"/\\|?*]', '_', filename)
    # Remove extra whitespace and dots
    sanitized = re.sub(r'\s+', '_', sanitized.strip())
    sanitized = sanitized.strip('.')
    
    # Ensure filename isn't too long
    if len(sanitized) > 200:
        sanitized = sanitized[:200]
    
    return sanitized

def save_contract(contract_text: str, contract_type: str, parties: List[str], output_dir: str = "./generated_contracts/") -> str:
    """Save generated contract to file"""
    
    # Ensure output directory exists
    Path(output_dir).mkdir(parents=True, exist_ok=True)
    
    # Generate filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    parties_str = "_".join([sanitize_filename(party) for party in parties[:2]])  # Limit to 2 parties for filename
    filename = f"{contract_type}_{parties_str}_{timestamp}.txt"
    filename = sanitize_filename(filename)
    
    file_path = os.path.join(output_dir, filename)
    
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            # Add metadata header
            f.write(f"# {contract_type.upper()} CONTRACT\n")
            f.write(f"# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"# Parties: {', '.join(parties)}\n")
            f.write("# Generated by: Legal AI Contract Generator\n")
            f.write(f"# Model: Gemini 1.5 Flash\n\n")
            f.write("=" * 80 + "\n\n")
            f.write(contract_text)
        
        logger.info(f"Contract saved to: {file_path}")
        return file_path
        
    except Exception as e:
        logger.error(f"Error saving contract: {str(e)}")
        raise

def load_template(template_path: str) -> Optional[str]:
    """Load contract template from file"""
    try:
        with open(template_path, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        logger.warning(f"Template not found: {template_path}")
        return None
    except Exception as e:
        logger.error(f"Error loading template: {str(e)}")
        return None

def format_contract_for_display(contract_text: str) -> str:
    """Format contract text for better display"""
    # Add proper spacing and formatting
    formatted = contract_text.replace('\n\n\n', '\n\n')  # Remove excessive line breaks
    formatted = re.sub(r'^(\d+\.)', r'\n\1', formatted, flags=re.MULTILINE)  # Add space before numbered sections
    return formatted.strip()

def extract_contract_metadata(contract_text: str) -> Dict[str, Any]:
    """Extract metadata from contract text"""
    metadata = {
        "word_count": len(contract_text.split()),
        "character_count": len(contract_text),
        "estimated_pages": len(contract_text) // 3000 + 1,  # Rough estimate
        "sections": len(re.findall(r'^\d+\.', contract_text, re.MULTILINE)),
        "generated_at": datetime.now().isoformat()
    }
    
    # Try to extract parties
    party_patterns = [
        r'between\s+([^,\n]+)\s+and\s+([^,\n]+)',
        r'Party\s*1[:\s]+([^,\n]+)',
        r'Client[:\s]+([^,\n]+)'
    ]
    
    for pattern in party_patterns:
        match = re.search(pattern, contract_text, re.IGNORECASE)
        if match:
            metadata["parties"] = [group.strip() for group in match.groups()]
            break
    
    return metadata

def validate_api_key(api_key: str) -> bool:
    """Validate API key format"""
    if not api_key:
        return False
    
    # Basic validation - adjust based on actual API key format
    if api_key.startswith(('sk-', 'AIza', 'xai-')):
        return True
    
    return False

def get_project_info() -> Dict[str, str]:
    """Get project information"""
    return {
        "name": "Legal AI Contract Generator",
        "version": "1.0.0",
        "description": "AI-powered legal contract generation and analysis system",
        "author": "Legal AI Team",
        "created": "2025",
        "tech_stack": "Python, Streamlit, Google Gemini API"
    }

def create_project_structure():
    """Create necessary project directories"""
    directories = [
        "./templates/",
        "./generated_contracts/",
        "./logs/"
    ]
    
    for directory in directories:
        Path(directory).mkdir(parents=True, exist_ok=True)
        logger.info(f"Created directory: {directory}")

def cleanup_old_contracts(output_dir: str = "./generated_contracts/", days_old: int = 30):
    """Clean up old generated contracts"""
    if not os.path.exists(output_dir):
        return
    
    cutoff_date = datetime.now().timestamp() - (days_old * 24 * 60 * 60)
    cleaned_count = 0
    
    for filename in os.listdir(output_dir):
        file_path = os.path.join(output_dir, filename)
        if os.path.isfile(file_path):
            if os.path.getctime(file_path) < cutoff_date:
                try:
                    os.remove(file_path)
                    cleaned_count += 1
                except Exception as e:
                    logger.error(f"Error removing old file {filename}: {str(e)}")
    
    if cleaned_count > 0:
        logger.info(f"Cleaned up {cleaned_count} old contract files")

# Usage tracking (optional)
class UsageTracker:
    """Track API usage and costs"""
    
    def __init__(self):
        self.usage_file = "./logs/usage.json"
        self.usage_data = self.load_usage()
    
    def load_usage(self) -> Dict[str, Any]:
        """Load usage data from file"""
        if os.path.exists(self.usage_file):
            try:
                with open(self.usage_file, 'r') as f:
                    return json.load(f)
            except Exception:
                pass
        
        return {
            "total_requests": 0,
            "contracts_generated": 0,
            "analyses_performed": 0,
            "daily_usage": {},
            "monthly_usage": {}
        }
    
    def save_usage(self):
        """Save usage data to file"""
        Path(os.path.dirname(self.usage_file)).mkdir(parents=True, exist_ok=True)
        with open(self.usage_file, 'w') as f:
            json.dump(self.usage_data, f, indent=2)
    
    def track_request(self, request_type: str):
        """Track a new request"""
        today = datetime.now().strftime("%Y-%m-%d")
        month = datetime.now().strftime("%Y-%m")
        
        self.usage_data["total_requests"] += 1
        
        if request_type == "contract_generation":
            self.usage_data["contracts_generated"] += 1
        elif request_type == "contract_analysis":
            self.usage_data["analyses_performed"] += 1
        
        # Daily tracking
        if today not in self.usage_data["daily_usage"]:
            self.usage_data["daily_usage"][today] = 0
        self.usage_data["daily_usage"][today] += 1
        
        # Monthly tracking
        if month not in self.usage_data["monthly_usage"]:
            self.usage_data["monthly_usage"][month] = 0
        self.usage_data["monthly_usage"][month] += 1
        
        self.save_usage()
    
    def get_usage_stats(self) -> Dict[str, Any]:
        """Get usage statistics"""
        today = datetime.now().strftime("%Y-%m-%d")
        month = datetime.now().strftime("%Y-%m")
        
        return {
            "total_requests": self.usage_data["total_requests"],
            "contracts_generated": self.usage_data["contracts_generated"],
            "analyses_performed": self.usage_data["analyses_performed"],
            "today_requests": self.usage_data["daily_usage"].get(today, 0),
            "month_requests": self.usage_data["monthly_usage"].get(month, 0)
        }

# Initialize usage tracker
usage_tracker = UsageTracker()
